/**
 * Report Generator for Accessibility Audit Results
 * Generates comprehensive reports in multiple formats
 */

import fs from 'fs/promises';
import path from 'path';

export class ReportGenerator {
  constructor(outputDir = './reports') {
    this.outputDir = outputDir;
  }

  /**
   * Generate all reports
   * @param {Object} auditResults - Complete audit results
   * @param {string} domain - Domain name for file naming
   * @returns {Object} Generated file paths
   */
  async generateReports(auditResults, domain) {
    await this.ensureOutputDir();
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filePrefix = `${domain}_${timestamp}`;
    
    const reports = {
      summary: await this.generateSummaryReport(auditResults, `${filePrefix}_summary.md`),
      detailed: await this.generateDetailedReport(auditResults, `${filePrefix}_detailed.csv`),
      statistics: await this.generateStatisticsReport(auditResults, `${filePrefix}_statistics.json`)
    };

    console.log(`Reports generated in ${this.outputDir}:`);
    console.log(`- Summary: ${reports.summary}`);
    console.log(`- Detailed: ${reports.detailed}`);
    console.log(`- Statistics: ${reports.statistics}`);

    return reports;
  }

  /**
   * Ensure output directory exists
   */
  async ensureOutputDir() {
    try {
      await fs.access(this.outputDir);
    } catch {
      await fs.mkdir(this.outputDir, { recursive: true });
    }
  }

  /**
   * Generate summary report in Markdown format
   * @param {Object} auditResults - Audit results
   * @param {string} filename - Output filename
   * @returns {string} File path
   */
  async generateSummaryReport(auditResults, filename) {
    const filePath = path.join(this.outputDir, filename);
    
    let markdown = `# Accessibility Audit Summary\n\n`;
    markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
    markdown += `**Domain:** ${auditResults.domain}\n`;
    markdown += `**Pages Audited:** ${auditResults.pagesAudited}\n\n`;

    // Executive Summary
    markdown += `## Executive Summary\n\n`;
    const overallStats = this.calculateOverallStatistics(auditResults);
    markdown += `The accessibility audit of ${auditResults.domain} reveals `;
    
    if (overallStats.criticalIssues === 0) {
      markdown += `**excellent accessibility implementation** with no critical issues found.\n\n`;
    } else {
      markdown += `**${overallStats.criticalIssues} critical issues** that need immediate attention.\n\n`;
    }

    markdown += `- **WCAG 2.1 AA Compliance:** ${overallStats.complianceLevel}\n`;
    markdown += `- **Critical Issues:** ${overallStats.criticalIssues}\n`;
    markdown += `- **High Priority Issues:** ${overallStats.highPriorityIssues}\n`;
    markdown += `- **Medium Priority Issues:** ${overallStats.mediumPriorityIssues}\n`;
    markdown += `- **Low Priority Issues:** ${overallStats.lowPriorityIssues}\n\n`;

    // Critical Issues
    if (overallStats.criticalIssues > 0) {
      markdown += `## Critical Issues (Must Fix)\n\n`;
      const criticalIssues = this.getIssuesBySeverity(auditResults, 'critical');
      criticalIssues.forEach((issue, index) => {
        markdown += `${index + 1}. **${issue.type}** - ${issue.message}\n`;
        markdown += `   - Recommendation: ${issue.recommendation}\n\n`;
      });
    }

    // High Priority Issues
    if (overallStats.highPriorityIssues > 0) {
      markdown += `## High Priority Issues\n\n`;
      const highPriorityIssues = this.getIssuesBySeverity(auditResults, 'high');
      highPriorityIssues.forEach((issue, index) => {
        markdown += `${index + 1}. **${issue.type}** - ${issue.message}\n`;
        markdown += `   - Recommendation: ${issue.recommendation}\n\n`;
      });
    }

    // Positive Findings
    markdown += `## Positive Findings\n\n`;
    const positiveFindings = this.getPositiveFindings(auditResults);
    positiveFindings.forEach((finding, index) => {
      markdown += `${index + 1}. **${finding.category}** - ${finding.description}\n\n`;
    });

    // Recommendations
    markdown += `## Recommendations\n\n`;
    const recommendations = this.getRecommendations(auditResults);
    recommendations.forEach((rec, index) => {
      markdown += `${index + 1}. ${rec}\n`;
    });

    markdown += `\n## Detailed Results\n\n`;
    markdown += `For detailed findings and specific remediation steps, see the CSV report.\n\n`;
    markdown += `---\n`;
    markdown += `*Generated by Accessibility Audit Tool*\n`;

    await fs.writeFile(filePath, markdown);
    return filePath;
  }

  /**
   * Generate detailed CSV report
   * @param {Object} auditResults - Audit results
   * @param {string} filename - Output filename
   * @returns {string} File path
   */
  async generateDetailedReport(auditResults, filename) {
    const filePath = path.join(this.outputDir, filename);
    
    let csv = 'Page URL,Category,Issue Type,Severity,Element,Description,Recommendation,Status,Evidence\n';

    auditResults.pages.forEach(pageResult => {
      const pageUrl = pageResult.url;
      const results = pageResult.results;

      // Semantic HTML issues
      if (results.semanticHTML && results.semanticHTML.issues) {
        results.semanticHTML.issues.forEach(issue => {
          csv += `"${pageUrl}",Semantic HTML,${issue.type},${issue.severity},HTML Structure,"${issue.message}","${issue.recommendation}",FAIL,""\n`;
        });
      }

      // Color contrast issues
      if (results.colorContrast) {
        results.colorContrast.forEach(contrast => {
          if (contrast.status === 'FAIL') {
            csv += `"${pageUrl}",Color Contrast,Insufficient Contrast,${contrast.compliance.passes ? 'PASS' : 'FAIL'},Text Elements,"Contrast ratio: ${contrast.contrastRatio}:1 (required: ${contrast.compliance.requiredRatio}:1)","Improve color contrast to meet WCAG AA standards",FAIL,"Text: ${contrast.textColor}, Background: ${contrast.backgroundColor}"\n`;
          }
        });
      }

      // ARIA issues
      if (results.ariaLabels && results.ariaLabels.issues) {
        results.ariaLabels.issues.forEach(issue => {
          csv += `"${pageUrl}",ARIA Labels,${issue.type},${issue.severity},${issue.element},"${issue.message}","${issue.recommendation}",FAIL,""\n`;
        });
      }

      // Keyboard navigation issues
      if (results.keyboardNavigation && results.keyboardNavigation.issues) {
        results.keyboardNavigation.issues.forEach(issue => {
          csv += `"${pageUrl}",Keyboard Navigation,${issue.type},${issue.severity},Interactive Elements,"${issue.message}","${issue.recommendation}",FAIL,""\n`;
        });
      }

      // Image issues
      if (results.images && results.images.issues) {
        results.images.issues.forEach(issue => {
          csv += `"${pageUrl}",Images,${issue.type},${issue.severity},Images,"${issue.message}","${issue.recommendation}",FAIL,"Image: ${issue.src || 'N/A'}"\n`;
        });
      }

      // Focus management issues
      if (results.focusManagement && results.focusManagement.issues) {
        results.focusManagement.issues.forEach(issue => {
          csv += `"${pageUrl}",Focus Management,${issue.type},${issue.severity},Interactive Elements,"${issue.message}","${issue.recommendation}",FAIL,""\n`;
        });
      }
    });

    await fs.writeFile(filePath, csv);
    return filePath;
  }

  /**
   * Generate statistics report in JSON format
   * @param {Object} auditResults - Audit results
   * @param {string} filename - Output filename
   * @returns {string} File path
   */
  async generateStatisticsReport(auditResults, filename) {
    const filePath = path.join(this.outputDir, filename);
    
    const statistics = {
      metadata: {
        domain: auditResults.domain,
        timestamp: new Date().toISOString(),
        pagesAudited: auditResults.pagesAudited,
        auditDuration: auditResults.auditDuration
      },
      overall: this.calculateOverallStatistics(auditResults),
      byCategory: this.calculateCategoryStatistics(auditResults),
      byPage: auditResults.pages.map(page => ({
        url: page.url,
        title: page.title,
        summary: page.results.summary,
        issues: this.countIssuesBySeverity(page.results)
      })),
      trends: this.calculateTrends(auditResults)
    };

    await fs.writeFile(filePath, JSON.stringify(statistics, null, 2));
    return filePath;
  }

  /**
   * Calculate overall statistics
   * @param {Object} auditResults - Audit results
   * @returns {Object} Overall statistics
   */
  calculateOverallStatistics(auditResults) {
    let totalIssues = 0;
    let criticalIssues = 0;
    let highPriorityIssues = 0;
    let mediumPriorityIssues = 0;
    let lowPriorityIssues = 0;
    let passes = 0;

    auditResults.pages.forEach(page => {
      const pageIssues = this.countIssuesBySeverity(page.results);
      totalIssues += pageIssues.total;
      criticalIssues += pageIssues.critical;
      highPriorityIssues += pageIssues.high;
      mediumPriorityIssues += pageIssues.medium;
      lowPriorityIssues += pageIssues.low;
      passes += pageIssues.passes;
    });

    const complianceLevel = criticalIssues === 0 ? 'WCAG AA Compliant' : 'Needs Improvement';

    return {
      totalIssues,
      criticalIssues,
      highPriorityIssues,
      mediumPriorityIssues,
      lowPriorityIssues,
      passes,
      complianceLevel
    };
  }

  /**
   * Count issues by severity for a page
   * @param {Object} pageResults - Page audit results
   * @returns {Object} Issue counts by severity
   */
  countIssuesBySeverity(pageResults) {
    let total = 0;
    let critical = 0;
    let high = 0;
    let medium = 0;
    let low = 0;
    let passes = 0;

    // Count issues from each category
    const categories = [
      pageResults.semanticHTML,
      pageResults.ariaLabels,
      pageResults.keyboardNavigation,
      pageResults.images,
      pageResults.focusManagement
    ];

    categories.forEach(category => {
      if (category && category.issues) {
        category.issues.forEach(issue => {
          total++;
          if (issue.severity === 'critical') {
            critical++;
          } else if (issue.severity === 'high') {
            high++;
          } else if (issue.severity === 'medium') {
            medium++;
          } else {
            low++;
          }
        });
      }
    });

    // Count color contrast failures
    if (pageResults.colorContrast) {
      pageResults.colorContrast.forEach(contrast => {
        if (contrast.status === 'FAIL') {
          total++;
          critical++;
        } else if (contrast.status === 'PASS') {
          passes++;
        }
      });
    }

    return { total, critical, high, medium, low, passes };
  }

  /**
   * Get issues by severity
   * @param {Object} auditResults - Audit results
   * @param {string} severity - Severity level
   * @returns {Array} Issues with specified severity
   */
  getIssuesBySeverity(auditResults, severity) {
    const issues = [];
    
    auditResults.pages.forEach(page => {
      const results = page.results;
      
      // Collect issues from all categories
      const categories = [
        results.semanticHTML,
        results.ariaLabels,
        results.keyboardNavigation,
        results.images,
        results.focusManagement
      ];

      categories.forEach(category => {
        if (category && category.issues) {
          category.issues.forEach(issue => {
            if (issue.severity === severity) {
              issues.push({ ...issue, pageUrl: page.url });
            }
          });
        }
      });

      // Check color contrast failures
      if (results.colorContrast) {
        results.colorContrast.forEach(contrast => {
          if (contrast.status === 'FAIL' && severity === 'critical') {
            issues.push({
              type: 'color_contrast',
              severity: 'critical',
              message: `Insufficient contrast ratio: ${contrast.contrastRatio}:1`,
              recommendation: 'Improve color contrast to meet WCAG AA standards',
              pageUrl: page.url
            });
          }
        });
      }
    });

    return issues;
  }

  /**
   * Get positive findings
   * @param {Object} auditResults - Audit results
   * @returns {Array} Positive findings
   */
  getPositiveFindings(auditResults) {
    const findings = [];

    // Check for good semantic structure
    const hasH1 = auditResults.pages.some(page => 
      page.results.semanticHTML && 
      page.results.semanticHTML.headings && 
      page.results.semanticHTML.headings.some(h => h.level === 'h1')
    );

    if (hasH1) {
      findings.push({
        category: 'Semantic HTML',
        description: 'Proper H1 heading structure found'
      });
    }

    // Check for good image accessibility
    const hasGoodImages = auditResults.pages.some(page => 
      page.results.images && 
      page.results.images.images && 
      page.results.images.images.some(img => img.hasAlt)
    );

    if (hasGoodImages) {
      findings.push({
        category: 'Image Accessibility',
        description: 'Images have proper alt text'
      });
    }

    // Check for keyboard navigation
    const hasKeyboardNav = auditResults.pages.some(page => 
      page.results.keyboardNavigation && 
      page.results.keyboardNavigation.focusableElements &&
      page.results.keyboardNavigation.focusableElements.length > 0
    );

    if (hasKeyboardNav) {
      findings.push({
        category: 'Keyboard Navigation',
        description: 'Good keyboard accessibility implementation'
      });
    }

    return findings;
  }

  /**
   * Get recommendations
   * @param {Object} auditResults - Audit results
   * @returns {Array} Recommendations
   */
  getRecommendations(auditResults) {
    const recommendations = [];

    const stats = this.calculateOverallStatistics(auditResults);

    if (stats.criticalIssues > 0) {
      recommendations.push('Fix all critical issues immediately');
    }

    if (stats.highPriorityIssues > 0) {
      recommendations.push('Address high priority issues for better accessibility');
    }

    recommendations.push('Test with screen readers and keyboard navigation');
    recommendations.push('Conduct user testing with assistive technologies');
    recommendations.push('Implement regular accessibility audits');

    return recommendations;
  }

  /**
   * Calculate category statistics
   * @param {Object} auditResults - Audit results
   * @returns {Object} Statistics by category
   */
  calculateCategoryStatistics(auditResults) {
    const categories = {
      semanticHTML: { total: 0, issues: 0 },
      colorContrast: { total: 0, issues: 0 },
      ariaLabels: { total: 0, issues: 0 },
      keyboardNavigation: { total: 0, issues: 0 },
      images: { total: 0, issues: 0 },
      focusManagement: { total: 0, issues: 0 }
    };

    auditResults.pages.forEach(page => {
      const results = page.results;

      // Count semantic HTML issues
      if (results.semanticHTML && results.semanticHTML.issues) {
        categories.semanticHTML.total++;
        categories.semanticHTML.issues += results.semanticHTML.issues.length;
      }

      // Count color contrast issues
      if (results.colorContrast) {
        categories.colorContrast.total++;
        const contrastIssues = results.colorContrast.filter(c => c.status === 'FAIL').length;
        categories.colorContrast.issues += contrastIssues;
      }

      // Count ARIA issues
      if (results.ariaLabels && results.ariaLabels.issues) {
        categories.ariaLabels.total++;
        categories.ariaLabels.issues += results.ariaLabels.issues.length;
      }

      // Count keyboard navigation issues
      if (results.keyboardNavigation && results.keyboardNavigation.issues) {
        categories.keyboardNavigation.total++;
        categories.keyboardNavigation.issues += results.keyboardNavigation.issues.length;
      }

      // Count image issues
      if (results.images && results.images.issues) {
        categories.images.total++;
        categories.images.issues += results.images.issues.length;
      }

      // Count focus management issues
      if (results.focusManagement && results.focusManagement.issues) {
        categories.focusManagement.total++;
        categories.focusManagement.issues += results.focusManagement.issues.length;
      }
    });

    return categories;
  }

  /**
   * Calculate trends
   * @param {Object} auditResults - Audit results
   * @returns {Object} Trend analysis
   */
  calculateTrends(auditResults) {
    return {
      mostCommonIssues: this.getMostCommonIssues(auditResults),
      pagesWithMostIssues: this.getPagesWithMostIssues(auditResults),
      categoryDistribution: this.getCategoryDistribution(auditResults)
    };
  }

  /**
   * Get most common issues
   * @param {Object} auditResults - Audit results
   * @returns {Array} Most common issues
   */
  getMostCommonIssues(auditResults) {
    const issueCounts = {};

    auditResults.pages.forEach(page => {
      const results = page.results;
      
      const categories = [
        results.semanticHTML,
        results.ariaLabels,
        results.keyboardNavigation,
        results.images,
        results.focusManagement
      ];

      categories.forEach(category => {
        if (category && category.issues) {
          category.issues.forEach(issue => {
            issueCounts[issue.type] = (issueCounts[issue.type] || 0) + 1;
          });
        }
      });
    });

    return Object.entries(issueCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([type, count]) => ({ type, count }));
  }

  /**
   * Get pages with most issues
   * @param {Object} auditResults - Audit results
   * @returns {Array} Pages with most issues
   */
  getPagesWithMostIssues(auditResults) {
    return auditResults.pages
      .map(page => ({
        url: page.url,
        title: page.title,
        issueCount: this.countIssuesBySeverity(page.results).total
      }))
      .sort((a, b) => b.issueCount - a.issueCount)
      .slice(0, 5);
  }

  /**
   * Get category distribution
   * @param {Object} auditResults - Audit results
   * @returns {Object} Category distribution
   */
  getCategoryDistribution(auditResults) {
    const distribution = {};

    auditResults.pages.forEach(page => {
      const results = page.results;
      const issueCount = this.countIssuesBySeverity(results).total;
      
      if (issueCount > 0) {
        const categories = ['semanticHTML', 'ariaLabels', 'keyboardNavigation', 'images', 'focusManagement'];
        categories.forEach(category => {
          if (results[category] && results[category].issues) {
            distribution[category] = (distribution[category] || 0) + results[category].issues.length;
          }
        });
      }
    });

    return distribution;
  }
}
